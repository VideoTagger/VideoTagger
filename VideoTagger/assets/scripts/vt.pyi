from abc import ABCMeta, abstractmethod
from typing import List, Optional, Tuple
from enum import Enum

class Script(metaclass=ABCMeta):
	def __init__(self: Script) -> None: ...
	@abstractmethod
	def has_progress(self: Script) -> bool: ...
	@abstractmethod
	def on_run(self: Script) -> None:
		"""This method doesn't need to be implemented since it isn't purely virtual"""
		...

	@property
	def progress(self: Script) -> float: ...
	@progress.setter
	def progress(self: Script, value: float) -> None: ...
	@property
	def progress_info(self: Script) -> str: ...
	@progress_info.setter
	def progress_info(self: Script, value: str) -> None: ...

class Timeline:
	def __repr__(self: Timeline) -> str: ...
	@property
	def segment_count(self: Timeline) -> int: ...

class Timestamp:
	@property
	def hours(self: Timestamp) -> int: ...
	@property
	def minutes(self: Timestamp) -> int: ...
	@property
	def seconds(self: Timestamp) -> int: ...
	@property
	def milliseconds(self: Timestamp) -> int: ...

	total_milliseconds: int

class Player:
	@property
	def current_timestamp(self: Player) -> Timestamp: ...

class TagAttributeType(Enum):
	bool = 0
	float = 1
	integer = 2
	string = 3
	shape = 4

class TagAttribute:
	def __init__(self: TagAttribute, type: TagAttributeType) -> None: ...

class TagAttributeInstance:
	def set_bool(self: TagAttributeInstance, value: bool) -> None: ...
	def set_integer(self: TagAttributeInstance, value: int) -> None: ...
	def set_float(self: TagAttributeInstance, value: float) -> None: ...
	def set_string(self: TagAttributeInstance, value: str) -> None: ...
	def set_rect(
		self: TagAttributeInstance, x: int, y: int, w: int, h: int
	) -> None: ...

class Tag:
	def __init__(self: Tag, name: str, color: int) -> None:
		"""color: uint32 formatted as 0xAABBGGRR"""
		...
	name: str
	color: int

	def add_attribute(self: Tag, name: str, type: TagAttributeType) -> TagAttribute: ...

class TagStorage:
	def add_tag(self: TagStorage, tag: Tag) -> bool: ...
	def clear(self: TagStorage) -> None: ...
	@property
	def list(self: TagStorage) -> List[Tag]: ...

class Video:
	@property
	def id(self: Video) -> int: ...
	@property
	def path(self: Video) -> str: ...
	@property
	def size(self: Video) -> Tuple[int, int]: ...

class Segment:
	# @property
	# def attributes(self: Segment) -> dict[int, TagAttributeInstance]: ...
	def get_attribute(
		self: Segment, video: Video, name: str
	) -> TagAttributeInstance: ...

class VideoGroup:
	def __init__(self: VideoGroup, name: str) -> None: ...
	def add_video(self: VideoGroup, video: Video, offset: int) -> None: ...
	def add_timestamp(self: VideoGroup, tag: Tag, start: int) -> Optional[Segment]: ...
	def add_segment(
		self: VideoGroup, tag: Tag, start: int, end: int
	) -> Optional[Segment]: ...

class Project:
	@property
	def name(self: Project) -> str: ...
	@property
	def videos(self: Project) -> List[Video]: ...
	@property
	def tags(self: Project) -> TagStorage: ...
	def import_video(self: Project, path: str) -> Optional[Video]: ...
	def find_group(self: Project, name: str) -> Optional[VideoGroup]: ...
	def add_group(self: Project, group: VideoGroup) -> bool: ...

def current_project() -> Optional[Project]: ...
def to_abgr(argb: int) -> int: ...
def log(message: str) -> None: ...
def warn(message: str) -> None: ...
def error(message: str) -> None: ...

timeline: Timeline
player: Player
